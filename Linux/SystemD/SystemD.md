# SystemD

## Подробный разбор

### 1. **systemd — система инициализации и менеджер служб**

- **Система инициализации** — это первый процесс, который запускается после загрузки ядра Linux.
- **Менеджер служб** — контролирует запуск, остановку и перезапуск программ, которые должны работать в фоне (демонов).

Пример: когда вы включаете сервер, systemd решает, когда стартовать `sshd`, `nginx`, `docker`, чтобы они были готовы к работе.

---

### 2. **Запускается первым процессом (PID 1) после ядра**

- После того как ядро Linux завершает свою инициализацию, оно запускает **одну программу**, указанную в параметре `init=` (по умолчанию — `/sbin/init`, который является symlink на systemd).
- У systemd всегда PID = 1, что означает:
    - Он "родитель" всех процессов в системе.
    - Если процесс "осиротел", systemd его подберёт и завершит правильно.

Проверить:

```bash
ps -p 1 -o comm=

```

---

### 3. **Отвечает за запуск служб при старте системы**

- systemd читает набор **unit-файлов** (описания служб и задач).
- Определяет, что, в каком порядке и с какими зависимостями нужно запустить.
- Это заменяет старые `rc.local` и скрипты `/etc/init.d/`.

---

### 4. **Управление зависимостями между службами**

- Службы часто зависят друг от друга.
    
    Пример:
    
    - `nginx` требует, чтобы сеть была поднята (`network.target`).
    - `docker` требует запущенного `containerd`.
- systemd строит **граф зависимостей** и запускает всё в правильном порядке.

---

### 5. **Логирование через journald**

- Встроенный сборщик логов **systemd-journald** собирает stdout/stderr всех служб.
- Логи хранятся в бинарном формате в `/var/log/journal/`.
- Просмотр:

```bash
journalctl -u nginx

```

- Это убирает необходимость в отдельных лог-файлах для каждой службы на старте.

---

### 6. **Пришёл на смену SysVinit и Upstart**

- **SysVinit** — старый метод, запускал скрипты последовательно (медленно).
- **Upstart** — событие-ориентированный init (использовался в Ubuntu до 15.04).
- **systemd**:
    - Запускает службы параллельно.
    - Управляет зависимостями.
    - Включает больше функций (таймеры, логирование, монтирование, сети).

---

## Подробный разбор

### 1. **Unit — базовый объект управления**

- **Unit** — это **конфигурационный файл**, описывающий, как systemd должна управлять каким-то ресурсом: службой, таймером, монтированием, сокетом и т.д.
- Расширение файла указывает тип юнита:
    - `.service` — служба (демон или процесс)
    - `.timer` — планировщик
    - `.mount` — монтирование
    - `.target` — набор юнитов
    - `.socket` — сетевой или UNIX-сокет
    - `.device` — устройство
    - и др.

**Проверить список юнитов:**

```bash
systemctl list-units

```

---

### 2. **Службы (service)**

- Это **демоны** или **программы**, которые работают в фоне.
- Пример: `nginx.service`, `sshd.service`, `docker.service`.
- Юнит `.service` описывает:
    - Как запустить процесс (`ExecStart=`).
    - Что делать при остановке (`ExecStop=`).
    - Как перезапускать при сбое (`Restart=`).

**Пример:**

```bash
sudo systemctl start nginx
sudo systemctl enable nginx

```

---

### 3. **Таймеры (timer)**

- Альтернатива **cron**, встроенная в systemd.
- Позволяют запускать службы по расписанию.
- `.timer` всегда связан с `.service`.
- Пример: `backup.timer` → запускает `backup.service` раз в день.

**Пример команды:**

```bash
sudo systemctl list-timers

```

---

### 4. **Монтирование (mount)**

- Юниты `.mount` автоматически монтируют файловые системы.
- Могут заменять записи в `/etc/fstab`.
- Имя юнита формируется из пути монтирования:
    - `/mnt/data` → `mnt-data.mount`

**Пример:**

```bash
sudo systemctl start mnt-data.mount

```

---

### 5. **Target — группы юнитов**

- **Target** — это **сборка нескольких юнитов**, чтобы запускать их вместе.
- Аналог старых **runlevels**:
    - `multi-user.target` — консольный режим (сервер).
    - `graphical.target` — с графическим интерфейсом.
- Можно создавать кастомные target'ы, например для DevOps-окружений.

**Проверить:**

```bash
systemctl get-default

```

---

## Подробный разбор

### 1. **/etc/systemd/system** — юниты администратора (высший приоритет)

- Здесь лежат **переопределённые** или **кастомные** unit-файлы.
- Если вы хотите изменить поведение службы, **не редактируйте оригинал** в `/usr/lib/systemd/system`, а скопируйте его сюда.
- Любой файл здесь **перекрывает** одноимённый файл в `/usr/lib/systemd/system`.
- Приоритет: systemd всегда смотрит в `/etc/systemd/system` в первую очередь.

**Пример:**

```bash
sudo cp /usr/lib/systemd/system/nginx.service /etc/systemd/system/
sudo nano /etc/systemd/system/nginx.service
sudo systemctl daemon-reload

```

---

### 2. **/run/systemd/system** — временные юниты

- Создаются **во время работы системы**.
- Обычно формируются скриптами или сервисами динамически.
- **Живут только до перезагрузки**.
- Пример: systemd создаёт здесь временные override-файлы для служб, если использовать команду:

```bash
sudo systemctl edit nginx

```

- Это удобно для временных изменений без перезаписи конфигурации.

---

### 3. **/usr/lib/systemd/system** — юниты пакетов

- Сюда ставятся unit-файлы, которые идут вместе с пакетами (через `apt`, `dnf`, `yum`).
- Эти файлы **не редактируются напрямую**, так как при обновлении пакета они будут перезаписаны.
- Содержат дефолтную конфигурацию службы, которую можно переопределить через `/etc/systemd/system`.

---

### Как systemd выбирает юнит

Приоритет поиска для `имя_юнита`:

1. `/etc/systemd/system/имя_юнита`
2. `/run/systemd/system/имя_юнита`
3. `/usr/lib/systemd/system/имя_юнита`

---

---

## Подробный разбор

### 1. **Запустить службу**

```bash
sudo systemctl start nginx

```

- Запускает службу **прямо сейчас**.
- Не включает её автозапуск при старте системы.
- Полезно для временного теста или однократного запуска.

---

### 2. **Остановить службу**

```bash
sudo systemctl stop nginx

```

- Останавливает службу, если она запущена.
- Не отключает автозапуск — при перезагрузке служба всё равно может стартовать, если включён `enable`.

---

### 3. **Перезапустить службу**

```bash
sudo systemctl restart nginx

```

- Останавливает, а затем запускает службу заново.
- Используется, когда изменена конфигурация и нужно применить её без полной перезагрузки системы.

---

### 4. **Проверить статус**

```bash
systemctl status nginx

```

- Показывает:
    - Текущее состояние (active, inactive, failed).
    - Последние строки логов.
    - PID и путь к исполняемому файлу.
- Если служба упала, тут же можно увидеть причину (иногда достаточно посмотреть последние 10–20 строк).

---

### 5. **Включить автозапуск**

```bash
sudo systemctl enable nginx

```

- Создаёт симлинк на unit-файл службы в каталог target'а, чтобы служба стартовала при загрузке.
- Изменения применяются **только при следующей загрузке**, если не использовать `-now`.

Пример сразу с запуском:

```bash
sudo systemctl enable --now nginx

```

---

### 6. **Отключить автозапуск**

```bash
sudo systemctl disable nginx

```

- Удаляет симлинк, чтобы служба не запускалась при старте.
- Не останавливает службу, если она уже запущена — для этого нужно выполнить `stop`.

---

💡 **Дополнительно полезно для DevOps:**

- **Проверить, включён ли автозапуск**:

```bash
systemctl is-enabled nginx

```

- **Список всех запущенных служб**:

```bash
systemctl list-units --type=service --state=running

```

---

---

## Подробный разбор

### 1. **Что такое target**

- **Target** — это **группа юнитов systemd**, которые должны быть запущены для определённого режима работы системы.
- Аналог старых **runlevels** из SysVinit:
    - runlevel 3 ≈ `multi-user.target`
    - runlevel 5 ≈ `graphical.target`
- Определяет:
    - Какие службы и демоны стартуют при загрузке.
    - Есть ли графическая оболочка или только консоль.
    - Используется ли GUI-дисплей менеджер (`gdm`, `lightdm` и т.д.).

---

### 2. **Проверка текущего режима**

```bash
systemctl get-default

```

- Показывает target, который будет применён **при следующей загрузке**.
- Пример вывода:

```
multi-user.target

```

---

### 3. **Графический режим**

```bash
sudo systemctl set-default graphical.target

```

- Загружает систему с графическим интерфейсом.
- Стартует **дисплей-менеджер** (например, GDM, LightDM).
- Обычно используется на рабочих станциях или серверах, где нужен GUI.

---

### 4. **Консольный режим**

```bash
sudo systemctl set-default multi-user.target

```

- Загружает систему в много-пользовательский консольный режим **без GUI**.
- Полезно для:
    - Серверов (в том числе DevOps и CI/CD-инфраструктуры).
    - Экономии ресурсов.
    - Удалённого администрирования через SSH.

---

### 5. **Одноразовое переключение режима (без изменения default)**

```bash
sudo systemctl isolate graphical.target
sudo systemctl isolate multi-user.target

```

- Переключает target прямо сейчас.
- Не меняет default target для следующей загрузки.

---

### 6. **Почему DevOps обычно использует multi-user.target**

- Серверы редко нуждаются в графическом окружении.
- Консольный режим:
    - Быстрее загружается.
    - Меньше потребляет ресурсов.
    - Меньше потенциальных точек отказа.

---

## Подробный разбор

### 1. **Что такое journald**

- **systemd-journald** — встроенный лог-демон systemd.
- Собирает:
    - Вывод stdout/stderr служб.
    - Сообщения ядра.
    - Системные сообщения (`syslog`).
- Логи хранятся в **бинарном формате**:
    - `/run/log/journal/` — временные (теряются при перезагрузке).
    - `/var/log/journal/` — постоянные (сохраняются между перезагрузками).
- Доступ к логам — только для root и пользователей группы `systemd-journal`.

---

### 2. **Все логи системы**

```bash
journalctl

```

- Показывает полный журнал со всех служб.
- Можно листать по `PgUp` / `PgDn`.
- Выход — `q`.

---

### 3. **Логи конкретной службы**

```bash
journalctl -u nginx

```

- Показывает только сообщения от `nginx.service`.
- Полезно, когда нужно найти причину сбоя конкретного сервиса.

---

### 4. **Логи в реальном времени**

```bash
journalctl -f

```

- Аналог `tail -f`, но для journald.
- Можно совмещать с `u`:

```bash
journalctl -u nginx -f

```

---

### 5. **Логи за определённый период**

```bash
journalctl -u nginx --since "10 min ago"
journalctl --since "2025-08-24 10:00" --until "2025-08-24 10:30"

```

- Удобно для анализа после инцидента или перезапуска.

---

### 6. **Дополнительные фильтры**

- **По уровню важности**:

```bash
journalctl -p err     # только ошибки
journalctl -p warning # предупреждения

```

- **По ядру**:

```bash
journalctl -k

```

---

### 7. **Почему это важно для DevOps**

- Нет нужды искать логи по разным файлам в `/var/log`.
- Удобно фильтровать и анализировать.
- Можно интегрировать с системами мониторинга и алертинга.

---

---

## Практика: Управление службой nginx через systemd

### 1. Установить nginx (если ещё не установлен)

```bash
sudo apt update && sudo apt install nginx -y      # Debian/Ubuntu
sudo yum install nginx -y                         # CentOS/RHEL
sudo dnf install nginx -y                         # Fedora

```

Проверить, что пакет установлен:

```bash
nginx -v

```

---

### 2. Запустить службу nginx

```bash
sudo systemctl start nginx

```

Проверить:

```bash
systemctl status nginx

```

В статусе должно быть **active (running)**.

---

### 3. Остановить и снова запустить

```bash
sudo systemctl stop nginx
systemctl status nginx   # должно быть inactive (dead)

sudo systemctl start nginx
systemctl status nginx   # снова active (running)

```

---

### 4. Включить автозапуск

```bash
sudo systemctl enable nginx

```

Проверить, включён ли автозапуск:

```bash
systemctl is-enabled nginx

```

💡 Можно включить автозапуск и сразу запустить:

```bash
sudo systemctl enable --now nginx

```

---

### 5. Проверить логи через journalctl

- **Все логи службы**:

```bash
journalctl -u nginx

```

- **В реальном времени**:

```bash
journalctl -u nginx -f

```

- **Только за последние 5 минут**:

```bash
journalctl -u nginx --since "5 min ago"

```

---

### 6. Проверить доступность nginx

Открыть браузер и перейти по адресу:

```
http://<IP_сервера>

```

или через `curl`:

```bash
curl -I http://localhost

```

В ответ должен прийти код `200 OK`.

---

---

## Ошибки и нюансы при работе с systemd

### 1. Если служба не стартует — смотреть `journalctl -xe`

- **Зачем:** `systemctl status` показывает краткий статус и последние пару строк логов.
    
    `journalctl -xe` даёт расширенное объяснение с цветом, временем и подсказками.
    
- **Пример:**

```bash
sudo systemctl start nginx
# Ошибка:
# Job for nginx.service failed because the control process exited with error code.

sudo journalctl -xe
# ...
# nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)

```

- **Вывод:** порт 80 уже занят другим процессом. Надо остановить конфликтующий сервис или изменить конфиг.

---

### 2. Приоритет каталогов `/etc/systemd/system` и `/usr/lib/systemd/system`

- Юниты (service-файлы) могут лежать в разных местах:
    - `/usr/lib/systemd/system` — дефолтные файлы от пакета (nginx, sshd и т.д.).
    - `/etc/systemd/system` — локальные переопределения, которые имеют **приоритет** над системными.
- **Пример:**
    - Установили nginx — systemd положил юнит в `/usr/lib/systemd/system/nginx.service`.
    - Вы хотите изменить параметры запуска (например, путь к PID-файлу) — создаёте новый файл или override в `/etc/systemd/system/nginx.service`.
- **Важно:** systemd всегда сначала смотрит в `/etc/systemd/system`. Если там есть юнит — он полностью заменяет системный.

---

### 3. Применение изменений в юните — `sudo systemctl daemon-reload`

- После изменения service-файла systemd **не читает его заново автоматически**.
- **Обязательный порядок:**

```bash
sudo nano /etc/systemd/system/nginx.service   # внесли правки
sudo systemctl daemon-reload                  # перечитать конфиги
sudo systemctl restart nginx                  # перезапустить службу

```

- **Без reload** systemd будет использовать старую версию юнита, даже если файл изменён.

---

💡 Частые ошибки:

1. Меняют юнит и сразу запускают `systemctl restart` без `daemon-reload` — изменения не применяются.
2. Создают override, но забывают, что приоритет у `/etc/systemd/system`, и правят не тот файл.
3. Ищут причину падения сервиса через `systemctl status`, но там лог обрезан — всегда проверяйте `journalctl -xe`.

---