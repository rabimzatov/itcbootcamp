# Ansible

## 1

### 1) Определение и назначение

1. **Ansible — инструмент автоматизации**: цель — автоматизировать повторяющиеся операции (установка ПО, конфигурация сервисов, развёртывание приложений, оркестрация взаимодействия нескольких сервисов).
2. Поддерживает три близких уровня задач:
    - **Configuration management** — состояние пакетов/файлов/сервисов на хостах (например: «nginx установлен»).
    - **Deployment** — установка и обновление приложений (копирование артефактов, миграции, обслуживание release).
    - **Orchestration** — упорядочение действий между хостами (например: поднять БД → прогнать миграции → поднять фронт).

### 2) Почему «прост в использовании»

- **YAML** — человекочитаемый формат (playbooks и inventory обычно в YAML), легко редактируется и ревьюится.
- **Декларативный стиль** — описываем *состояние* (present/absent, enabled/disabled), а не пошаговые imperative команды.
- Большая библиотека **модулей** (пакеты, файлы, сервисы, cloud-модули, network-модули) — не нужно писать скрипты под каждую задачу.

### 3) Что значит «agentless» — реалии

- Ansible использует **SSH** (Control Node → Managed Node). На целевой машине модуль (скрипт на Python) временно копируется и запускается, затем удаляется.
- Для Linux обычно требуется Python на управляемом хосте. Если Python отсутствует — можно использовать `raw`/`shell` модули, но это снижает удобство и идемпотентность.
- Для Windows — Ansible использует **WinRM**, а не SSH.
- Вывод: «без агентов» ≠ «ничего не нужно ставить» — нужны стандартные возможности (SSH/WinRM) и, как правило, Python.

### 4) Идемпотентность — почему важно и как работает

- **Идемпотентность** = повторный запуск плейбука не должен ломать систему и должен менять только при необходимости.
- Достигается за счёт модулей, которые проверяют текущее состояние и выполняют изменения только если нужно.
- Пример:
    - Задача `package: name=nginx state=present` → если nginx уже установлен — модуль вернёт `ok`, не выполнит установку.
    - Если использовать `shell: apt-get install nginx` — shell-задача может выполнить установку каждый раз и не будет идемпотентной.

## 2

# Где используется

### 1) Массовое управление серверами

Что это значит

- Одновременные операции на сотнях/тысячах хостов: обновления пакетов, изменение конфигураций, развёртывание исправлений, сбор данных.

Почему Ansible подходит

- Push-модель (control → managed) удобна для централизованного запуска задач.
- Можно запускать в батчах (`serial`) или настраивать количество параллельных воркеров (`forks`), чтобы не перегрузить сеть/сервера.
- Модули Ansible делают задачи идемпотентными — безопасно повторять.

Пример: playbook обновления в батчах

```yaml
- name: Обновление пакетов батчами
  hosts: all
  become: yes
  serial: 10               # обрабатывать по 10 хостов одновременно
  tasks:
    - name: Обновить индекс пакетов (Debian)
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Обновить все пакеты (Debian)
      apt:
        upgrade: dist
      when: ansible_os_family == "Debian"

    - name: Обновить пакеты (RHEL)
      yum:
        name: "*"
        state: latest
      when: ansible_os_family == "RedHat"

```

---

### 2) Автоматизация рутинных задач

Что это значит

- Ежедневные, повторяющиеся операции: создание cron-джоб, чистка логов, ротация, бэкапы, развёртывание конфигов, проверка состояния.

Почему Ansible подходит

- Чётко описываем, что должно быть (cron-запись, файл конфигов, сервис запущен) — Ansible применит изменения только при необходимости.
- Модули для cron, template, lineinfile, copy, file позволяют избежать shell-скриптов.

Пример: создание cron-задачи и шаблон конфигурации

```yaml
- name: Настройка бэкапа
  hosts: backup
  become: yes
  tasks:
    - name: Установить скрипт бэкапа
      copy:
        src: files/backup.sh
        dest: /usr/local/bin/backup.sh
        mode: '0755'

    - name: Создать cron задачу
      cron:
        name: "backup-db"
        minute: "0"
        hour: "2"
        job: "/usr/local/bin/backup.sh >> /var/log/backup.log 2>&1"
        user: root

```

---

### 3) Подготовка окружений для CI/CD

Что это значит

- Автоматическое создание/обновление окружений (dev/stage/prod) как часть пайплайна CI (Jenkins/GitLab CI/GitHub Actions).
- Деплой артефактов, миграции БД, запуск сервисов.

Почему Ansible подходит

- Является «последним шагом» в пайплайне: получает результат сборки и настраивает хосты/сервисы.
- Плейбуки легко параметризуются переменными (env vars, `-extra-vars`), теги позволяют запускать только нужные части.

Пример playbook для деплоя артефакта (интеграция в CI)

```yaml
- name: Деплой приложения
  hosts: app
  become: yes
  vars:
    artifact_url: "{{ lookup('env','ARTIFACT_URL') }}"
  tasks:
    - name: Скачиваем артефакт
      get_url:
        url: "{{ artifact_url }}"
        dest: /tmp/app.tar.gz

    - name: Распаковать артефакт
      unarchive:
        src: /tmp/app.tar.gz
        dest: /opt/myapp
        remote_src: yes

    - name: Перезапустить сервис
      systemd:
        name: myapp
        state: restarted
        enabled: yes

```

Как это использовать в CI:

- В пайплайне CI сформировать `ARTIFACT_URL` и вызвать
    
    `ansible-playbook -i hosts.ini deploy.yml --extra-vars "ARTIFACT_URL=..." --tags deploy`
    

---

### 4) Настройка облачной инфраструктуры

Что это означает

- Автоматизация конфигурации и (частично) управления облачными ресурсами: создание и конфиг ВМ, настройка сетей, хранилищ, конфигурация сервисов.

Реальные подходы

- Ansible может управлять облачными ресурсами через коллекции/модули (для AWS, GCP, Azure и т.д.) и/или работать поверх уже созданной инфраструктуры.
- Частая практика: **Terraform** для создания и изменения инфраструктуры (provisioning), Ansible — для конфигурации ПО на созданных ресурсах (provisioning -> configuration).

Рабочий паттерн

1. Создать/изменить ресурсы (Terraform / cloud console / cloud SDK).
2. Получить список хостов (динамический inventory или экспорт host list).
3. Запустить Ansible для настройки ПО и конфигураций.

Динамический inventory

- Для облаков используются плагины динамического инвентори — они возвращают актуальные хосты и метаданные. Это избавляет от ручного правления hosts.ini.

Пример (логика, без конкретного провайдера)

- Terraform создаёт VM и сохраняет IPs в output.
- CI получает `terraform output -json` → формирует inventory → запускает `ansible-playbook -i dynamic_hosts.yml configure.yml`.

Рекомендации

- Для чувствительных данных используйте Vault или KMS/Secret Manager провайдера.
- Используйте теги/метки облака для группирования хостов и динамического инвентаря.
- Тестируйте workflow в отдельном проекте облака (dev account).

---

## 3

# Ключевые особенности

### 1) Agentless (SSH / WinRM — «без агентов»)

Что это значит

- Ansible не требует постоянного агента на целевых хостах. Контролирующая машина (control node) подключается по SSH (Linux/Unix) или WinRM (Windows).
    
    Как это работает технически
    
- При запуске Ansible копирует небольшой временный скрипт/модуль на целевой хост, выполняет его и удаляет.
- Для Linux обычно требуется Python на целевом хосте (модули написаны на Python). Если Python отсутствует — можно использовать `raw`/`shell`, но это снижает удобство и идемпотентность.
    
    Оптимизация и параметры соединения
    
- `ansible.cfg`: `forks`, `pipelining`, `timeout`, `control_path`/ControlPersist (оптимизация SSH), `host_key_checking`.
- Можно выбирать драйвер соединения: `ssh` (по умолчанию), `paramiko` (альтернатива), `local`.
    
    Практические проблемы и рекомендации
    
- Убедиться в доступности SSH-ключей/правильных пользователей (`ansible_user`, `ansible_ssh_private_key_file`).
- На Windows — настраивать WinRM (в отличие от SSH требуется подготовка).
- Для сетевого оборудования используются соответствующие connection-плагины (netconf, nxos, etc.).
- Не путать «нет агента» с «ничего не нужно» — нужны стандартные возможности доступа (SSH/WinRM) и, как правило, Python.

### 2) Idempotency (повторный запуск безопасен)

Определение и зачем важно

- Идемпотентность = повторный запуск плейбука не должен менять систему, если желаемое состояние уже достигнуто. Это делает автоматизацию надёжной и предсказуемой.
    
    Как достигается
    
- Стандартные модули (apt/yum/service/file/user/template и т.д.) сначала проверяют текущее состояние и выполняют действия только если требуется.
- Результаты задач помечаются как `ok` (ничего не сделано) или `changed` (изменение выполнено).
    
    Примеры
    
- Идемпотентный модуль:

```yaml
- name: Установить nginx
  apt:
    name: nginx
    state: present

```

- Неидемпотентный shell (плохо):

```yaml
- name: Установить nginx (неидемпотентно)
  shell: apt-get install -y nginx

```

Как писать идемпотентно, если нужно выполнить shell-команду

- Использовать параметры `creates`, `removes`, `changed_when`, `check_mode` или предварительную проверку в `when`.

```yaml
- name: Распаковать архив, если папки нет
  unarchive:
    src: /tmp/app.tar.gz
    dest: /opt/myapp
    remote_src: yes
  when: not (ansible_facts['some_check'] is defined and ansible_facts['some_check'])

```

Проверки перед выполнением

- `ansible-playbook --check --diff` — dry-run и просмотр отличий. Рекомендую запускать для production-операций.

### 3) Declarative (описываем *что*, а не *как*)

Концепция

- В declarative-подходе вы описываете желаемое состояние (напр., «пакет X установлен», «файл с этим содержимым существует»), а Ansible решает *как* это обеспечить при помощи модулей.
    
    Преимущества
    
- Меньше деталей реализации в коде; playbooks проще читать и ревьюить.
- Проще достигать идемпотентности и повторяемости.
- Отделяет intent (намерение) от исполнения — легче переносить на другие ОС/дистрибутивы, т.к. модули инкапсулируют реализацию.
    
    Пример сравнения
    
- Declarative (рекомендовано):

```yaml
- name: Создать пользователя
  user:
    name: deploy
    groups: sudo
    state: present

```

- Imperative (плохо — сложно поддерживать):

```yaml
- name: Создать пользователя (выполнять команды)
  shell: useradd -m -G sudo deploy || true

```

Когда всё-таки нужен imperative

- Для одноразовых ad-hoc действий, тестов, или если модуль отсутствует. Но даже тогда стараться обернуть в idempotent-логику.

### 4) YAML-плейбуки (структура и практики)

Минимальная структура playbook

```yaml
- name: Example play
  hosts: web
  become: yes
  vars:
    http_port: 80
  tasks:
    - name: Установить nginx
      apt:
        name: nginx
        state: present
    - name: Скопировать конфиг
      template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
      notify: Restart nginx

  handlers:
    - name: Restart nginx
      service:
        name: nginx
        state: restarted

```

Ключевые элементы

- `hosts` — группа/хосты из inventory
- `tasks` — список задач (модули)
- `handlers` — отложенные действия, срабатывают при `changed`
- `vars`, `vars_files` — переменные
- `roles` — структурирование и переиспользование
- `tags` — запуск частей плейбука по меткам (`-tags`)
    
    Практические советы по YAML
    
- Соблюдать отступы — YAML чувствителен к пробелам.
- Использовать Jinja2-шаблоны для конфигов (`templates`) — не вставлять большие строки прямо в task.
- Разделять `group_vars` и `host_vars` для окружений; не хранить секреты в репозитории (использовать `ansible-vault`).
    
    Роль — рекомендуемая структура
    

```
roles/
  myrole/
    tasks/main.yml
    handlers/main.yml
    templates/
    files/
    vars/main.yml
    defaults/main.yml
    meta/main.yml

```

Инструменты качества

- `ansible-lint` — статический анализ плейбуков/ролей.
- `molecule` + `testinfra` — тесты ролей в контейнерах/VM.
    
    Статусы выполнения
    
- `ok` — состояние уже соответствует (нет изменений)
- `changed` — Ansible внес изменение
- `failed` — задача завершилась с ошибкой
- `skipped` — задача пропущена (условие `when`)
    
    Ошибки, связанные с YAML и как их избегать
    
- Неправильные отступы → syntax error. Используйте `ansible-playbook play.yml --syntax-check`.
- Неправильные типы переменных (строка vs булево) → проверяйте с `debug: var=...`.

---

## 4

# Что такое YAML

### 1. Краткая история и название

- Первоначальное расширение — *Yet Another Markup Language*; в дальнейшем принято рекурсивное *YAML Ain't Markup Language* (подчёркивает, что YAML — не разметка, а формат данных).
- Сегодня актуальна спецификация YAML 1.2; большинство инструментов поддерживают поведение, близкое к ней.

### 2. Почему YAML часто выбирают (практическая польза)

- Читаемость: человек может быстро понять структуру конфигурации.
- Поддержка комментариев (`#`) — удобно для документации конфигов.
- Поддерживает удобные приёмы (anchors/aliases, merge) для избежания дублирования.
- JSON является валидным YAML (YAML 1.2 — надмножество JSON), поэтому легко интегрируется с сервисами, которые работают с JSON.

### 3. Синтаксис — основы (с примерами)

**Мэппинг (словарь):**

```yaml
user:
  name: alice
  uid: 1001

```

**Список (sequence):**

```yaml
servers:
  - web1.example.com
  - web2.example.com

```

**Вложенные структуры:**

```yaml
app:
  name: myapp
  ports:
    - 80
    - 443

```

**Комментарии:**

```yaml
# Это комментарий
key: value  # комментарий после значения

```

**Многострочные строки:**

- `|` — literal: сохраняет переносы строк.
- `>` — folded: переносы строк заменяются пробелами (полезно для длинных параграфов).

```yaml
text_literal: |
  Строка1
  Строка2

text_folded: >
  Это длинный текст,
  который превратится в одну строку.

```

**Anchors / Aliases / Merge:**

```yaml
defaults: &defaults
  retries: 3
  timeout: 30

service:
  <<: *defaults
  name: web

```

Это удобно, чтобы переиспользовать блоки конфигурации и избегать дублирования.

### 4. Типы данных и неожиданные преобразования

- YAML поддерживает строки, числа, boolean, null, даты и т.д.
- Внимание: некоторые значения могут *неожиданно* интерпретироваться как boolean/числа (например, `no`, `on`, `yes`, `2019-01-01`) в некоторых парсерах.
    
    Рекомендация: явно заключайте в кавычки (`'no'`, `"2024-01-01"`) если значение должно быть строкой.
    
- Современные парсеры обычно следуют спецификации, но поведение может отличаться между версиями/библиотеками — тестируйте критичные значения.

### 5. YAML vs JSON vs XML — сравнение + пример

**Кратко:**

- YAML — читаемость и выразительность, позволяет комментарии и anchors.
- JSON — строгий синтаксис, широко используется в API; проще парсить в большинстве языков.
- XML — громоздкий, но формально строгий, поддерживает схемы (XSD), пространства имён — полезен где требуется формальная валидация.

**Одинаковый пример (данные о приложении):**

YAML:

```yaml
app:
  name: myapp
  version: "1.2.0"
  authors:
    - Alice
    - Bob

```

JSON:

```json
{"app":{"name":"myapp","version":"1.2.0","authors":["Alice","Bob"]}}

```

XML:

```xml
<app>
  <name>myapp</name>
  <version>1.2.0</version>
  <authors>
    <author>Alice</author>
    <author>Bob</author>
  </authors>
</app>

```

**Важно:** JSON — это допустимый YAML (в YAML 1.2 JSON-валидный документ распознаётся как YAML). Но JSON не поддерживает комментарии и anchors.

### 6. Ansible-специфичные замечания по YAML

- Playbooks, inventory (YAML-формат), vars, defaults — всё обычно в YAML; в Ansible обычно используют 2 пробела для отступов.
- Пример простого playbook:

```yaml
- name: Установить nginx
  hosts: web
  become: yes
  tasks:
    - name: Установить пакет
      apt:
        name: nginx
        state: present

```

- Переменные: осторожно с неявным приведением типов; лучше явно задавать строки/числа и тестировать в `-check` режиме.

### 7. Безопасность и ограничения

- **Не загружайте незнакомый YAML через небезопасные загрузчики.** В Python, например, `yaml.load()` (старые версии PyYAML) может выполнить произвольную десериализацию; используйте `safe_load()` или безопасный парсер.
- Anchor/alias-эксплозия и большие вложенные структуры в теории могут вызвать DoS через большие объёмы памяти — используйте ограничения парсера при работе с внешне поступающими файлами.

### 8. Частые ошибки и способы отладки

- Ошибка синтаксиса (отступы, табы) → используйте `ansible-playbook play.yml --syntax-check` и `yamllint`.
- Неправильный тип переменной (`no` как boolean) → добавьте кавычки.
- Неявное преобразование дат/чисел → явно указывайте строковый формат или используйте явные теги `!!str` при необходимости.
- Для CLI-работы с YAML используйте `yq` (фильтрация/модификация) и `yamllint` для проверки стиля.

### 9. Лучшие практики при работе с YAML

- Используйте 2 пробела для отступа (Ansible-стиль). Никогда не используйте табы.
- Кавычки для значений, которые могут быть неправильно интерпретированы (`'no'`, `'on'`, `'0001'`).
- Избегайте больших inline-блоков — используйте `|` или `>` для многострочных текстов.
- Применяйте `yamllint` и `ansible-lint` в CI.
- Храните секреты вне открытых YAML (Ansible Vault, HashiCorp Vault, KMS).
- Используйте anchors/aliases экономно — для читаемости они помогают, но могут скрывать логику.

---

## 5

# Архитектура Ansible

### Control Node

- Это машина (обычно laptop/VM/CI-агент/контрольный сервер), где установлен `ansible` / `ansible-playbook`.
- Хранит: `playbooks`, `roles`, `ansible.cfg`, `group_vars/host_vars`, `vault`файлы.
- Отсюда выполняется соединение с Managed Nodes (push-модель).
- Ключевые настройки (`ansible.cfg`): `inventory`, `forks`, `remote_user`, `private_key_file`, `pipelining`, `control_path`, `timeout`.
- Control Node может быть интегрирован в CI (Jenkins/GitLab) или управляться через AWX/Tower.

### Managed Nodes

- Целевые хосты, которые Ansible настраивает. Это могут быть:
    - Linux/Unix (SSH),
    - Windows (WinRM),
    - Сетевые устройства (netconf/napalm/ssh),
    - Контейнеры, облачные инстансы и пр.
- Обычно требуется доступ (SSH/WinRM) и наличие интерпретатора (часто Python) для выполнения модулей.
- Ansible временно копирует модуль/скрипт на managed node, выполняет и забирает результат — постоянный агент не нужен.

### Inventory (список хостов и групп)

- **Типы inventory:**
    - **Статический (ini / YAML)** — простой файл `hosts.ini` или `hosts.yml`.
    - **Динамический** — скрипт или плагин (например, cloud-плагины), который возвращает текущие хосты (JSON/YAML).
- **Структура:**
    - Группы: `[web]`, `[db]` или `web:` в YAML.
    - Переменные: `group_vars/`, `host_vars/` или inline (`ansible_host=...`, `ansible_user=...`).
- Примеры:

INI:

```
[web]
web1 ansible_host=10.0.0.1 ansible_user=deployer

[db]
db1 ansible_host=10.0.0.10

```

YAML:

```yaml
all:
  children:
    web:
      hosts:
        web1:
          ansible_host: 10.0.0.1

```

- **Динамический inventory** часто используется при работе с облаками — тогда inventory генерируется в runtime и может кэшироваться.

### Playbooks

- Playbook — основной «скрипт» в YAML, описывающий *что* делать (plays -> hosts -> tasks).
- Структура: `hosts`, `vars`, `tasks`, `handlers`, `roles`, `tags`, `become`.
- Playbook исполняется последовательно: выбираются hosts из inventory → (опционально) собираются facts → выполняются tasks в порядке, с учётом `serial`, `strategy`, `when` и `tags`.

Пример (минимум):

```yaml
- name: Установка nginx
  hosts: web
  become: yes
  tasks:
    - name: Установить nginx
      apt:
        name: nginx
        state: present

```

### Modules

- Модуль — единица работы (аналог функции): `apt`, `yum`, `service`, `copy`, `template`, `user`, `uri`, `aws_ec2`, `docker_container` и т.д.
- Модули реализуют логику и чаще всего выполняются на managed node (есть also_local action plugins).
- Modules возвращают структуру JSON (статусы `ok/changed/failed`) — Ansible интерпретирует результат.
- Начиная с Ansible 2.10+ модули сгруппированы в **Collections** (пакеты модулей), доступны через Ansible Galaxy / коллекции.

---

## Технический поток выполнения — пошагово (что реально происходит)

1. Пользователь запускает `ansible-playbook -i inventory playbook.yml`.
2. Ansible читает `ansible.cfg`, inventory и playbook.
3. Определяются целевые хосты (inventory, фильтры, tags).
4. (Опционально) Сбор фактов: модуль `setup` запускается и собирает ansible_facts.
5. Для каждой задачи Ansible:
    - Определяет хосты и последовательность (учитывая `serial`, `strategy`).
    - Для каждого хоста открывается SSH (или WinRM/другой connection), иногда с ControlPersist/ssh-multiplexing.
    - На хост временно копируется модуль (обычно Python-скрипт) и запускается.
    - Модуль выполняет работу и возвращает JSON-ответ.
    - Ansible удаляет временные файлы и сохраняет результат (`ok/changed/failed`).
6. Handlers запускаются после завершения задач, если на них были `changed`.
7. Результат выводится пользователю; при `-check` и `-diff` — только симуляция.

---

## Важные дополнительные компоненты

- **Handlers** — отложенные действия (перезапуск сервиса только при изменениях).
- **Facts** — переменные, собранные о хосте (`ansible_facts`). Можно собирать/отключать.
- **Roles** — модульная структура для повторного использования (`tasks/ handlers/ templates/ vars/ defaults/ files/ meta`).
- **Plugins** — inventory, connection, callback, lookup, cache и пр. Они расширяют поведение Ansible.
- **Collections & Galaxy** — распространяемые пакеты модулей/ролей.
- **AWX / Ansible Tower** — UI/REST/RBAC/Job Scheduling/Logs для Enterprise.
- **Ansible Vault** — шифрование секретов.

---

## Конфигурация и полезные команды

- Посмотреть версию:

```bash
ansible --version

```

- Показать inventory:

```bash
ansible-inventory -i hosts.ini --list --yaml

```

- Проверить соединение (ping-модуль):

```bash
ansible all -i hosts.ini -m ping

```

- Список модулей/док:

```bash
ansible-doc -l
ansible-doc apt

```

- Синтаксическая проверка playbook:

```bash
ansible-playbook playbook.yml --syntax-check

```

`ansible.cfg` — ключевые опции:

```
[defaults]
inventory = ./hosts.ini
forks = 50
remote_user = deploy
private_key_file = ~/.ssh/id_rsa
host_key_checking = False
pipelining = True
timeout = 30

```

---

## Масштабирование, производительность, устойчивость

- Параллелизм: настройка `forks` в `ansible.cfg`.
- Батчи: `serial` в playbook — обрабатывать хосты частями.
- SSH-мультиплексинг (`ControlPersist`, `control_path`) экономит время на установке соединений.
- Для очень большого флота: использовать AWX/Tower, event-driven подход, либо pull-модели (например ansible-pull) или поставить промежуточные средства (orchestration controllers).

---

## Частые ошибки и диагностика

- Проблема: **SSH-аутентификация** → проверка `ansible_user`, `ansible_ssh_private_key_file`, `vvv` вывод.
- Проблема: **Python отсутствует на хосте** → либо установить Python, либо использовать `raw`/`shell` (нежелательно).
- Проблема: **не тот inventory / хосты не выбраны** → `ansible-inventory --list`.
- Диагностика: запуск `ansible-playbook -i hosts.ini play.yml -vvv`, проверка логов AWX/Tower.

---

## 6

# Как работает Ansible

## 1) Подключение по SSH (или WinRM для Windows)

- **Что происходит сначала:** control node читает `ansible.cfg`, inventory и playbook; определяет список хостов.
- **Установка соединения:** Ansible использует указанный connection-плагин (по умолчанию `ssh` для Unix-подобных). При массовом запуске открывается несколько параллельных SSH-сессий (`forks` в `ansible.cfg`).
- **Оптимизация соединений:** обычно используется SSH-multiplexing / ControlPersist (анsible автоматически может использовать `control_path`), что уменьшает накладные расходы при множественных задачах. Параметр `pipelining` уменьшает количество операций (может отключить необходимость создания временных файлов).
- **Права и эскалация:** если нужна привилегированная установка — Ansible использует `become` (sudo/su/polkit) уже внутри SSH-сессии; для Windows — WinRM + соответствующие методы.

## 2) Выполнение модуля (например `yum`, `service`)

- **Transfer & execution flow (обобщённо):**
    1. Control node формирует модуль (обычно Python-скрипт) + аргументы (JSON).
    2. Модуль копируется на managed node во временную директорию (например `/tmp/ansible-...`) через SFTP/SCP или передаётся через stdin, в зависимости от параметров (`pipelining` и connection-плагина).
    3. На managed node модуль запускается интерпретатором (обычно Python) с передачей аргументов.
    4. Модуль выполняет проверку текущего состояния и при необходимости вносит изменения.
    5. Модуль печатает (stdout) JSON-ответ с полями: `changed`, `failed`, `msg`, `rc`, `invocation` и др.
    6. Control node читает JSON и на его основе формирует статус задачи.
    7. Временные файлы удаляются (если не включён debug/capture).
- **Когда модуль не может быть использован:** Ansible может выполнить `raw`, `shell` или `command` модули — они не инкапсулируют идемпотентность и чаще используются для одноразовых/обходных действий (например, установка Python на свежем хосте).

## 3) Возврат статуса (интерпретация и вывод)

- **Типичные статусы в выводе `ansible-playbook`:**
    - `ok` — задача не изменила систему (состояние уже соответствовало желаемому).
    - `changed` — задача внесла изменения.
    - `failed` — задача завершилась с ошибкой; playbook может остановиться в зависимости от `ignore_errors`.
    - `skipped` — задача пропущена из-за условия `when` или тегов.
    - `unreachable` — хост недоступен (ошибка соединения).
- **Итоговая сводка** — в конце вывода playbook показывает количество `ok/changed/unreachable/failed/skipped`.
- **Формат возвращаемого результата модуля:** JSON-объект. Пример (сокращённо):

```json
{
  "changed": true,
  "rc": 0,
  "stdout": "",
  "stderr": "",
  "invocation": { "module_args": { "name": "nginx", "state": "present" } }
}

```

- **Логирование и callback-плагины:** Ansible использует callback-плагины для форматирования вывода (по умолчанию — human readable). Можно подключать callback для логирования в файлы/внешние системы.

## 4) Идемпотентность — изменения только при необходимости

- **Суть:** модуль должен сначала **проверить** текущее состояние и вернуть `changed: false`, если ничего менять не нужно.
- **Почему это важно:** повторный запуск playbook не должен ломать систему и должен быть безопасным для production.
- **Примеры:**
    - Идемпотентный `apt`/`yum` модуль:
        
        ```yaml
        - apt:
            name: nginx
            state: present
        
        ```
        
        → если nginx уже установлен → `ok` (или `changed: false`).
        
    - Неидемпотентный `shell`:
        
        ```yaml
        - shell: apt-get install -y nginx
        
        ```
        
        → будет выполняться каждый раз и может возвращать `changed` каждый запуск (зависит от реализации команды).
        
- **Как сделать shell-задачу идемпотентной:** использовать параметры `creates`/`removes`, проверять с помощью `stat`, использовать `changed_when`/`check_mode`, или регистрировать вывод и принимать решение с `when`.
    
    ```yaml
    - name: Распаковать, только если нет папки
      unarchive:
        src: /tmp/app.tar.gz
        dest: /opt/myapp
        remote_src: yes
    
    ```
    
- **Check mode и diff:**
    - `ansible-playbook --check --diff` симулирует изменения; модули поддерживающие `check_mode` корректно покажут, что бы изменили. Это помогает убедиться в идемпотентности.

---

# Техническая последовательность выполнения playbook (с полной картиной)

1. Парсинг конфигурации (`ansible.cfg`) и inventory.
2. Определение таргет-групп/хостов (hosts из playbook, фильтры, tags).
3. (Опционально) Сбор фактов (`setup` module) — факты записываются в `ansible_facts`.
4. Для каждой play/host: открываются SSH-сессии (параллельно, в зависимости от forks).
5. Для каждой задачи:
    - Ansible решает, какие хосты выполняют задачу (учитывая `serial`, `strategy`).
    - Формируется модуль и аргументы → отправляется на хост.
    - На хосте модуль выполняет проверку и/или изменение → отвечает JSON.
    - Ansible парсит JSON, помечает `ok/changed/failed` и, при `changed`, помечает handlers для выполнения.
6. По окончании всех задач — выполняются handlers, если были `changed`.
7. Вывод итогов и завершение.

---

# Отладка — команды и что смотреть

- `ansible-playbook play.yml -vvv` — подробный вывод; покажет, как Ansible копирует модуль и что получает в ответ.
- `ansible all -i hosts.ini -m ping -vvv` — проверить SSH/WinRM доступ.
- `ansible-inventory -i hosts.ini --list --yaml` — проверить inventory.
- `ansible-doc <module>` — документация по модулю (поддержка `check_mode`, параметры).
- `ansible-playbook --check --diff` — dry-run + показать разницу.

---

# Частые ошибки и способы решения

- **unreachable / SSH auth failure** — проверьте ключи, `ansible_user`, `ansible_ssh_private_key_file`, права, `vvv` для деталей.
- **Module failed: Python not found** — установить Python на целевой хост или использовать `raw` для начальной установки Python.
- **Неидемпотентные задачи** — заменить `shell`/`command` на стандартный модуль или добавить проверки (`creates`, `when`, `changed_when`).
- **Handlers не запускаются** — handler вызывается только если задача вернула `changed: true`. Проверить логику задачи.

---

# Примеры (короткие демонстрации)

1. **Проверка связи:**

```bash
ansible all -i hosts.ini -m ping
# Ответ каждого хоста: {"ping": "pong"} -> Ansible пометит ok/unreachable

```

1. **Playbook в действии (простой):**

```yaml
- hosts: web
  become: yes
  tasks:
    - name: Установить nginx
      apt:
        name: nginx
        state: present

```

Запуск: `ansible-playbook -i hosts.ini site.yml --diff` — покажет, какие пакеты будут установлены (или не будут, если уже есть).

---

## 7

# Преимущества Ansible

---

## 1) Простота — почему это преимущество (детально)

- **Agentless:** Ansible не требует постоянного агента на целевых серверах — control node подключается по SSH (Unix) или WinRM (Windows). Это уменьшает операционные издержки (нет отдельного процесса/демона для установки и управления).
    - *Практически:* достаточно иметь доступ по SSH и, как правило, интерпретатор (обычно Python) на целевом хосте.
    - *Риск/ограничение:* «без агента» ≠ «ничего не нужно» — нужно настроить доступ (ключи, пользователи, возможно установить Python).
- **YAML-плейбуки:** человекочитаемый формат, легко ревьюится в git, понятен не только инженерам.
    - *Пример мини-плейбука:*
        
        ```yaml
        - hosts: web
          become: yes
          tasks:
            - name: Установить nginx
              apt:
                name: nginx
                state: present
        
        ```
        
- **Высокий порог входа:** многие базовые задачи решаются без программирования — достаточно знаний YAML и логики задач.
- **Быстрый старт:** простая установка (`pip install ansible` или пакетный менеджер), быстрые ad-hoc команды (`ansible all -m ping`) дают мгновенную обратную связь.

---

## 2) Универсальность — охват платформ и сценариев

- **ОС:** Linux/Unix через SSH, Windows через WinRM (специальные коллекции/модули для Windows).
- **Облака:** есть модули/коллекции для управления ресурсами в AWS/GCP/Azure/других провайдерах — Ansible умеет и provisioning (частично), и конфигурацию ПО на инстансах. Частая архитектура: Terraform для создания ресурсов + Ansible для конфигурации.
- **Сетевое оборудование:** коллекции и connection-плагины для Cisco, Juniper, Arista, поддержка NETCONF/napalm и т.д.
- **Контейнеры/оркестрация:** модули для Docker, Kubernetes (интеграция с kubeconfig, операции на кластере).
- **Преимущество:** единый инструмент для разных уровней стека — уменьшает количество разных средств и знание нескольких DSL.
- **Практическая заметка:** для некоторых нишевых устройств/функций всё ещё могут потребоваться специфичные инструменты, но Ansible часто покрывает большую часть задач.

---

## 3) Большое сообщество и роли (Ansible Galaxy)

- **Ansible Galaxy / Collections:** централизованные репозитории ролей и коллекций — готовые решения для популярных задач (nginx, mysql, docker и т.п.).
- **Преимущества:**
    - Быстрое переиспользование — можно взять роль и адаптировать.
    - Сообщество поддерживает большое количество готовых коллекций для облаков, сетей, приложений.
- **Риски и рекомендации:**
    - Качество ролей варьируется — всегда проверяйте код, версии, зависимости; фиксируйте версии (pin).
    - Используйте `ansible-galaxy install <role>` и проверяйте `meta` и `README`.
    - Для production — лучше использовать проверенные/официальные коллекции или поддерживать свои роли с тестами (molecule).
- **Практически:** наличие большого community ускоряет внедрение, даёт примеры реализации best-practices и готовые шаблоны.

---

## 4) Лёгкая интеграция с CI/CD (практическая выгода)

- **Запуск в пайплайне:** Ansible легко запускается из Jenkins, GitLab CI, GitHub Actions, Azure DevOps — достаточно вызывать `ansible-playbook` с нужным inventory/переменными.
    - *Пример команды в пайплайне:*
        
        `ansible-playbook -i inventory/stage.yml deploy.yml --extra-vars "artifact_url=$ARTIFACT_URL"`
        
- **Контейнеризация:** Ansible можно запускать внутри Docker-контейнера (стабильный runtime), что упрощает reproducible CI-окружение.
- **AWX / Tower:** GUI/REST интерфейс и scheduling, RBAC, аудит — удобно, если хотите вынести управление playbooks в self-service для команд или автоматизировать триггеры.
- **Преимущества для CI/CD:**
    - Ansible покрывает последний этап пайплайна — конфигурация и деплой на хосты.
    - Можно автоматически запускать `-check`/`-diff` как шаг в pipeline для безопасной проверки изменений.
    - Теги (`-tags`) позволяют выполнять в пайплайне только нужные части playbook (smoke, deploy, migrate).
- **Рекомендации:** храните секреты отдельно (Ansible Vault или внешние secret managers) и интегрируйте проверку ролей (ansible-lint) в CI.

---

## Практические преимущества сводкой (что вы реально выигрываете)

- Меньше ручной работы → меньше человеческих ошибок.
- Единая модель управления для разных сред → меньше контекста для инженеров.
- Быстрая автоматизация рутинных операций → экономия времени.
- Быстрое прототипирование окружений для разработки/тестирования.
- Возможность интеграции в автоматические пайплайны и self-service через AWX/Tower.

---

## Ограничения (честно)

- **Масштабирование:** push-модель имеет ограничения при очень большом количестве хостов — нужны оптимизации (`forks`, `serial`), AWX/Tower или альтернативные подходы (pull-модели).
- **Зависимость от окружения:** на managed nodes часто нужен Python; в некоторых минимальных образах это надо планировать.
- **Качество community-кода:** не все роли на Galaxy безопасны/поддерживаемы — проверяйте.
- **Идемпотентность:** зависит от того, как написаны плейбуки/модули; плохие практики (shell без проверок) ломают преимущества.

---

## Практические команды / примеры (быстрая шпаргалка)

- Проверить ansible: `ansible --version`
- Проверить связь: `ansible all -i hosts.ini -m ping`
- Запустить playbook (prod): `ansible-playbook -i inventory/prod.yml site.yml --check --diff`
- Установить роль из Galaxy: `ansible-galaxy role install <namespace.role_name>`
- Проверка синтаксиса: `ansible-playbook playbook.yml --syntax-check`
- Статический анализ: `ansible-lint playbook.yml`

---

## 8

---

### Коротко — ключевые факты

- **Ansible:** простая push-модель, agentless (SSH/WinRM), YAML-плейбуки — быстрый вход и гибкая оркестрация.
- **Puppet:** ориентирован на модель «desired state» с агентами (minion) и периодическим само-приведением к состоянию; хорош для централизованной конфигурации и compliance.
- **Chef:** ориентирован на программистов/разработчиков — рецепты на Ruby (DSL), мощная программируемость, более высокий порог входа.
- **SaltStack:** гибридный подход (master/minion + salt-ssh для agentless), очень быстрый remote-execution и event-driven автоматика; сложнее в настройке, но хорош для реального времени.

---

## Технические различия (подробно)

**Модель связи**

- Ansible — **push**: control node инициирует соединения (SSH/WinRM) и выполняет задачи.
- Puppet — **pull** (обычно): агенты периодически опрашивают сервер конфигураций и применяют каталоги. Есть и `puppet apply` для локального выполнения.
- Chef — **pull** при использовании `chef-client` на нодах (или `chef-client` по расписанию); есть локальные режимы (`chef-client -z`).
- SaltStack — **master/minion** (minions постоянно соединяются с master), что позволяет мастеру мгновенно отправлять команды; также поддерживается **salt-ssh** (agentless).

**Язык/DSL**

- Ansible — YAML + Jinja2 (декларативно/структурно; люди читают).
- Puppet — собственный declarative DSL (пишут manifests).
- Chef — Ruby DSL (recipes/cookbooks) — более процедурный/императивный потенциал.
- Salt — YAML (SLS files) + Jinja; state-формат похож на declarative.

**Идемпотентность / enforcement**

- Все инструменты стремятся к идемпотентности, но:
    - Puppet/Chef/Salt (minion) — постоянное поддержание desired state (drift correction).
    - Ansible — по умолчанию **единоразовый push**; чтобы поддерживать состояние, нужно регулярное выполнение (cron/CI/ansible-pull/AWX scheduling).

**Производительность / масштаб**

- Агентные архитектуры (Puppet, Chef, Salt minion) обычно масштабируются лучше для очень больших флотов (постоянные соединения, менее многократные авторизации).
- Ansible может параллельно выполнять на многих хостах (`forks`, `serial`), но push-модель накладывает ограничения по сетевым пикам и времени запуска.

---

## Плюсы и минусы — по каждому инструменту

### Ansible

- Плюсы: очень низкий порог входа; нет агентов; простой синтаксис (YAML); отлично для ad-hoc и оркестрации; быстрое прототипирование.
    
    − Минусы: по умолчанию не обеспечивает постоянное enforcement; при очень большом количестве хостов требует оптимизаций; idempotency зависит от корректности playbooks.
    

### Puppet

- Плюсы: сильная модель desired state и compliance; хорош для корпоративной конфигурации и аудита; mature ecosystem.
    
    − Минусы: требует управления агентами/сертификатами; больше операционного оверхеда; steeper learning curve, если команда привыкла к простым скриптам.
    

### Chef

- Плюсы: мощный, программируемый (Ruby) — гибкость для сложной логики; хорошие практики для тестирования cookbooks (Test Kitchen).
    
    − Минусы: порог входа выше (нужны навыки Ruby), структура cookbook/knife/chef-server требует дисциплины; для админов без dev-опыта может быть тяжеловат.
    

### SaltStack

- Плюсы: очень быстрый remote execution и event bus; подходит для real-time orchestration и event-driven automation; поддерживает и agent, и agentless режим.
    
    − Минусы: конфигурация master/minion и event system сложнее; экосистема формул/коллекций менее «простая» чем Galaxy/Forge по удобству.
    

---

## Типичные кейсы / когда какой инструмент выбирать

- **Ansible** — быстрый деплой, конфигурация приложения, CI/CD-шаги, сеть/инфраструктурная оркестрация, сценарии с разношёрстным окружением.
- **Puppet** — корпоративная конфигурация, compliance/регуляторные требования, долгосрочное поддержание состояния и аудит.
- **Chef** — сложные инфраструктурные сценарии, где нужна программируемая логика и тесная интеграция с Dev-практиками.
- **SaltStack** — real-time задачи (миграция, live-операции), monitoring+reaction («on event run state»), быстрые массовые команды.

---

## Частые ошибки / подводные камни

- Выбирать инструмент только по «модности», а не по потребностям (scale, compliance, навыки команды).
- Недооценивать операционный overhead агентов (обновления, сертификаты).
- Игнорировать тестирование и idempotency (особенно при использовании shell/command).
- Считать, что один инструмент решит всё — в крупных окружениях часто применяют комбинации (Terraform + Ansible; Puppet для compliance; Ansible для orchestration).

---

## Рекомендации по выбору (короткий чек-лист)

- Нужна быстрая оркестрация и низкий порог входа → **Ansible**.
- Нужна постоянная поддержка desired state, аудит и compliance → **Puppet**.
- Нужна программируемая логика и сильный дев-ориентированный workflow → **Chef**.
- Нужна высокая скорость удалённых команд и event-driven automation → **SaltStack**.

---